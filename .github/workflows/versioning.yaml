name: Version and Release Automation

# Documentation:
# This workflow handles the automated releasing of the package.
# It can be triggered automatically by pushing to main or creating a tag.
#
# MANUAL RELEASE:
# If you want to manually release a new version, go to the "Actions" tab, select "Version and Release Automation",
# and click "Run workflow". You can select:
# - Level: patch, minor, major, or prerelease.
# - Create Prerelease: Check this if you want the version to be a prerelease (e.g. 1.0.1-next.0).
#
# The workflow will:
# 1. Bump the version in package.json (if manual).
# 2. Push the bump to main (if manual).
# 3. Create a GitHub Release and Tag.
# 4. Publish to NPM (tag 'next' for prereleases, 'latest' for stable).
# 5. Prepare the next development version (bump to next patch + '-next') and create a PR (only for stable releases).

on:
  push:
    branches:
      - main
    paths:
      - package.json
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      level:
        description: 'Version Bump Level'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
      create_prerelease:
        description: 'Create as a prerelease (e.g. -next.0)?'
        required: false
        default: false
        type: boolean

jobs:
  release:
    name: Create tag and release on version change
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Manual Version Bump
        if: github.event_name == 'workflow_dispatch'
        id: manual_bump
        run: |
          LEVEL="${{ inputs.level }}"
          CREATE_PRE="${{ inputs.create_prerelease }}"

          if [ "$LEVEL" == "prerelease" ]; then
             # User specifically asked for prerelease bump (e.g. 1.0.0-next.0 -> 1.0.0-next.1)
             npm version prerelease --preid=next --no-git-tag-version
          elif [ "$CREATE_PRE" == "true" ]; then
             # User asked for level (e.g. patch) but as prerelease (e.g. 1.0.0 -> 1.0.1-next.0)
             npm version pre$LEVEL --preid=next --no-git-tag-version
          else
             # Standard stable bump (e.g. 1.0.0 -> 1.0.1)
             npm version $LEVEL --no-git-tag-version
          fi

          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "Bumping to $NEW_VERSION"

          # Commit and Push
          git add package.json package-lock.json
          git commit -m "chore: bump version to $NEW_VERSION"
          git push origin HEAD:main

          NEW_SHA=$(git rev-parse HEAD)
          echo "manual_bump_occurred=true" >> "$GITHUB_OUTPUT"
          echo "new_sha=$NEW_SHA" >> "$GITHUB_OUTPUT"

      - name: Determine package version changes
        id: versions
        run: |
          # If we just bumped manually, package.json is already updated on disk.
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          export CURRENT_VERSION
          echo "current_version=${CURRENT_VERSION}" >> "$GITHUB_OUTPUT"

          if [[ "${CURRENT_VERSION}" == *-next ]]; then
            echo "allow_publish=false" >> "$GITHUB_OUTPUT"
          else
            echo "allow_publish=true" >> "$GITHUB_OUTPUT"
          fi

          # If manual bump occurred, HEAD is the bump commit. HEAD^ is the old version.
          # If push event, HEAD is the push. HEAD^ is previous.
          # We need to make sure we can compare correctly.

          if git show HEAD^:package.json > /tmp/prev-package.json 2>/dev/null; then
            PREVIOUS_VERSION=$(node -p "JSON.parse(require('fs').readFileSync('/tmp/prev-package.json','utf8')).version")
          else
            PREVIOUS_VERSION=""
          fi

          echo "previous_version=${PREVIOUS_VERSION}" >> "$GITHUB_OUTPUT"

          if [ "${CURRENT_VERSION}" != "${PREVIOUS_VERSION}" ]; then
            echo "version_changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "version_changed=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ "${CURRENT_VERSION}" != *-* && "${CURRENT_VERSION}" != "${PREVIOUS_VERSION}" ]]; then
            echo "prepare_next=true" >> "$GITHUB_OUTPUT"
          else
            echo "prepare_next=false" >> "$GITHUB_OUTPUT"
          fi

          if [[ "${CURRENT_VERSION}" == *-* ]]; then
            echo "npm_tag=next" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "npm_tag=latest" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
          fi

          node <<'NODE'
          const fs = require('fs');
          const current = process.env.CURRENT_VERSION;
          function nextPatch(version) {
            const [major, minor, patchPart] = version.split('.');
            const numericPatch = parseInt(patchPart.split('-')[0], 10);
            return `${major}.${minor}.${numericPatch + 1}`;
          }
          const nextDev = `${nextPatch(current)}-next`;
          fs.writeFileSync('/tmp/next-dev-version', nextDev);
          NODE

          NEXT_DEV_VERSION=$(cat /tmp/next-dev-version)
          echo "next_dev_version=${NEXT_DEV_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Create git tag and GitHub release
        # Run if version changed OR if manually dispatched (redundant check if bump worked, but safe)
        if: steps.versions.outputs.version_changed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ steps.versions.outputs.current_version }}';
            if (!version) {
              core.setFailed('Package version could not be determined.');
              return;
            }
            const tagName = `v${version}`;
            const { owner, repo } = context.repo;

            async function ensureTag() {
              try {
                await github.rest.git.getRef({ owner, repo, ref: `tags/${tagName}` });
                core.info(`Tag ${tagName} already exists.`);
              } catch (error) {
                // If we manually bumped and pushed, the SHA is the current HEAD (which is the bump commit)
                const sha = '${{ steps.manual_bump.outputs.manual_bump_occurred }}' === 'true'
                  ? '${{ steps.manual_bump.outputs.new_sha }}'
                  : context.sha;
                await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${tagName}`, sha });
                core.info(`Created tag ${tagName} at ${sha}.`);
              }
            }

            await ensureTag();

            // Check if release exists
            let releaseExists = false;
            try {
              await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
              core.info(`Release for ${tagName} already exists.`);
              releaseExists = true;
            } catch (error) {
              if (error.status !== 404) {
                 core.warning(`Error checking for release: ${error.message}`);
              }
            }

            if (!releaseExists) {
               try {
                   await github.rest.repos.createRelease({
                    owner,
                    repo,
                    tag_name: tagName,
                    name: tagName,
                    generate_release_notes: true,
                    draft: false,
                    prerelease: ${{ steps.versions.outputs.is_prerelease }}
                  });
                  core.info(`Release for ${tagName} created.`);
               } catch (error) {
                  // Handle "already_exists"
                  if (error.response && error.response.data && error.response.data.errors) {
                    const alreadyExists = error.response.data.errors.some(e => e.code === 'already_exists');
                    if (alreadyExists) {
                       core.info(`Release for ${tagName} already exists (caught during creation).`);
                       return;
                    }
                  }
                  throw error;
               }
            }

      - name: Setup Node.js for publishing
        if: steps.versions.outputs.version_changed == 'true' && steps.versions.outputs.allow_publish == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'

      - name: Publish package to npm
        if: steps.versions.outputs.version_changed == 'true' && steps.versions.outputs.allow_publish == 'true'
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          npm ci
          npm run build
          npm publish --access=public --tag ${{ steps.versions.outputs.npm_tag }}

      - name: Prepare next -next development version
        if: steps.versions.outputs.prepare_next == 'true'
        run: |
          NEXT_DEV_VERSION=${{ steps.versions.outputs.next_dev_version }}
          export NEXT_DEV_VERSION
          node <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const nextVersion = process.env.NEXT_DEV_VERSION;
          const pkgPath = path.join(process.cwd(), 'package.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = nextVersion;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');

          const lockPath = path.join(process.cwd(), 'package-lock.json');
          if (fs.existsSync(lockPath)) {
            const lock = JSON.parse(fs.readFileSync(lockPath, 'utf8'));
            lock.version = nextVersion;
            if (lock.packages && lock.packages['']) {
              lock.packages[''].version = nextVersion;
            }
            fs.writeFileSync(lockPath, JSON.stringify(lock, null, 2) + '\n');
          }
          NODE

      - name: Create next iteration pull request
        if: steps.versions.outputs.prepare_next == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "chore: prepare ${{ steps.versions.outputs.next_dev_version }}"
          title: "chore: prepare ${{ steps.versions.outputs.next_dev_version }}"
          body: |
            This pull request prepares the repository for the next development cycle.

            * Released version `${{ steps.versions.outputs.current_version }}`
            * Bumps the package version to `${{ steps.versions.outputs.next_dev_version }}` to continue `-next` development.
          branch: "chore/prepare-${{ steps.versions.outputs.next_dev_version }}"
          delete-branch: true
          add-paths: |
            package.json
            package-lock.json
